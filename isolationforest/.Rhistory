ci=TRUE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
library(data.tree)
createDataTree <- function(h2oTree) {
h2oTreeRoot = h2oTree@root_node
dataTree = Node$new(h2oTreeRoot@split_feature)
dataTree$type = 'split'
addChildren(dataTree, h2oTreeRoot)
return(dataTree)
}
addChildren <- function(dtree, node) {
if(class(node)[1] != 'H2OSplitNode') return(TRUE)
feature = node@split_feature
id = node@id
na_direction = node@na_direction
if(is.na(node@threshold)) {
leftEdgeLabel = printValues(node@left_levels,
na_direction=='LEFT', 4)
rightEdgeLabel = printValues(node@right_levels,
na_direction=='RIGHT', 4)
}else {
leftEdgeLabel = paste("<", node@threshold,
ifelse(na_direction=='LEFT',',NA',''))
rightEdgeLabel = paste(">=", node@threshold,
ifelse(na_direction=='RIGHT',',NA',''))
}
left_node = node@left_child
right_node = node@right_child
if(class(left_node)[[1]] == 'H2OLeafNode')
leftLabel = paste("prediction:", left_node@prediction)
else
leftLabel = left_node@split_feature
if(class(right_node)[[1]] == 'H2OLeafNode')
rightLabel = paste("prediction:", right_node@prediction)
else
rightLabel = right_node@split_feature
if(leftLabel == rightLabel) {
leftLabel = paste(leftLabel, "(L)")
rightLabel = paste(rightLabel, "(R)")
}
dtreeLeft = dtree$AddChild(leftLabel)
dtreeLeft$edgeLabel = leftEdgeLabel
dtreeLeft$type = ifelse(class(left_node)[1] == 'H2OSplitNode', 'split', 'leaf')
dtreeRight = dtree$AddChild(rightLabel)
dtreeRight$edgeLabel = rightEdgeLabel
dtreeRight$type = ifelse(class(right_node)[1] == 'H2OSplitNode', 'split', 'leaf')
addChildren(dtreeLeft, left_node)
addChildren(dtreeRight, right_node)
return(FALSE)
}
printValues <- function(values, is_na_direction, n=4) {
l = length(values)
if(l == 0)
value_string = ifelse(is_na_direction, "NA", "")
else
value_string = paste0(paste0(values[1:min(n,l)], collapse = ', '),
ifelse(l > n, ",...", ""),
ifelse(is_na_direction, ", NA", ""))
return(value_string)
}
library(solitude)
library(dplyr)
# utility dir func (moved necessary dependancies in src folder in root of repo)
dir <- getwd()
if (tail(strsplit(dir,"/")[[1]],1) == "isolationforest"){
guide.set <- read.csv("guide_set.csv")
setwd("..")
source("isolationforest/simulate_test_data.R")
setwd(dir)
}
#You need to first run simulation code to create a Data.set
input_df <- Data.set
levels(input_df$peptide)
# input_df <- input_df %>% filter(peptide != "EACFAVEGPK")
input_df <- input_df %>% filter(peptide == "SLHTLFGDELCK")
# input_df <- input_df %>% filter(peptide == "YICDNQDTISSK")
input_df <- input_df[,2:7]
# scale all numeric cols
# num_cols <- colnames(dplyr::select_if(input_df, is.numeric))
# input_df <- input_df %>% group_by(peptide) %>% mutate_at(num_cols, ~(scale(., center = T) %>% as.vector))
pass <-  input_df[input_df$RESPONSE == "PASS",]
fail <-  input_df[input_df$RESPONSE == "FAIL",]
maindf <- rbind(sample_frac(pass,0.95),sample_frac(fail,0.05)) %>% dplyr::select(-peptide)
# maindf <- rbind(pass[1:950,],tail(fail,50)) %>% dplyr::select(-peptide)
iso <- isolationForest$new(
num_trees = 100,
sample_size = nrow(maindf)*0.05,
replace = T,
mtry = base::round(sqrt(length(colnames(maindf)))),
seed = 123
)
# fit for data
iso$fit(maindf[,1:4])
## Building Isolation Forest ... done
## Computing depth of terminal nodes ... done
# Obtain anomaly scores
# results<-iso$scores
results <- iso$predict(maindf[,1:4])
# quantiles of anomaly scores
contamination.factor<-0.95
# q<-quantile(results$anomaly_score[1:900],
#             probs = seq(contamination.factor,
#                         contamination.factor, length.out = 1))
#2. way of calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
outlier<-as.factor(ifelse(results$anomaly_score >= thresh, "FAIL", "PASS"))
results<-cbind(results, outlier, RESPONSE=maindf$RESPONSE)
table(results$RESPONSE, results$outlier)
# 2-d Plots
pch <- rep(".", length(maindf$RESPONSE))
pch[results$outlier == "FAIL"] <- "+"
col <- rep("black", length(maindf$RESPONSE))
col[results$outlier == "FAIL"] <- "red"
labels <- rep(".", length(maindf$RESPONSE))
labels[results$outlier == "FAIL"] <- "X"
sum(labels != '.')
pairs(maindf[1:4], pch=pch, col=col)
biplot(prcomp(maindf[1:4],scale. = T,center = T), cex=.8, xlabs=labels)
table(results$RESPONSE, results$outlier)
plot_pca <- function(data){
# Assumes all numeric cols with anomaly score col last
num_cols <- colnames(dplyr::select_if(input_df, is.numeric))
pca <- prcomp(data[c(num_cols)], scale. = T , center = T)
pcainfo <-  summary(pca)
x <- as.vector(pca[["x"]][,1])
y <- as.vector(pca[["x"]][,2])
z <- as.vector(pca[["x"]][,3])
anom <- base::as.vector(data[,length(data)])
pca_df <-  as.data.frame(cbind(x,y,z,anom))
pca_df <- pca_df %>% mutate(anom = if_else(anom == "FAIL", 'Anomaly', 'Normal') )
fig <- plot_ly(pca_df, x = ~x, y = ~y, z = ~z, color = ~anom, colors = c('#BF382A', '#0C4B8E'))
fig <- fig %>% add_markers()
fig <- fig %>% layout(scene = list(xaxis = list(title = paste('PC1 ', pcainfo$importance[2]*100,"%")),
yaxis = list(title = paste('PC2 ', pcainfo$importance[5]*100,"%")),
zaxis = list(title = paste('PC3 ', pcainfo$importance[8]*100,"%"))))
fig
}
anom_df <- cbind(maindf[1:4],results$outlier)
plot_pca(anom_df)
library(plotly)
plot_pca <- function(data){
# Assumes all numeric cols with anomaly score col last
num_cols <- colnames(dplyr::select_if(input_df, is.numeric))
pca <- prcomp(data[c(num_cols)], scale. = T , center = T)
pcainfo <-  summary(pca)
x <- as.vector(pca[["x"]][,1])
y <- as.vector(pca[["x"]][,2])
z <- as.vector(pca[["x"]][,3])
anom <- base::as.vector(data[,length(data)])
pca_df <-  as.data.frame(cbind(x,y,z,anom))
pca_df <- pca_df %>% mutate(anom = if_else(anom == "FAIL", 'Anomaly', 'Normal') )
fig <- plot_ly(pca_df, x = ~x, y = ~y, z = ~z, color = ~anom, colors = c('#BF382A', '#0C4B8E'))
fig <- fig %>% add_markers()
fig <- fig %>% layout(scene = list(xaxis = list(title = paste('PC1 ', pcainfo$importance[2]*100,"%")),
yaxis = list(title = paste('PC2 ', pcainfo$importance[5]*100,"%")),
zaxis = list(title = paste('PC3 ', pcainfo$importance[8]*100,"%"))))
fig
}
anom_df <- cbind(maindf[1:4],results$outlier)
plot_pca(anom_df)
# Load rpart and rpart.plot
library(rpart)
library(rpart.plot)
install.packages("rpart.plot")
View(maindf)
View(maindf)
tree <- rpart(outlier~., data=rpart.df, cp=.02)
# Load rpart and rpart.plot
library(rpart)
library(rpart.plot)
# Create a decision tree model
rpart.df <- cbind(maindf[1:4],results$outlier)
tree <- rpart(outlier~., data=rpart.df, cp=.02)
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdBu", shadow.col="gray", nn=TRUE)
rpart.df
tree <- rpart(Anomaly~., data=rpart.df, cp=.02)
# Load rpart and rpart.plot
library(rpart)
library(rpart.plot)
# Create a decision tree model
Anomaly <- as.vector(results$outlier)
rpart.df <- cbind(maindf[1:4],Anomaly)
tree <- rpart(Anomaly~., data=rpart.df, cp=.02)
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdBu", shadow.col="gray", nn=TRUE)
# Load rpart and rpart.plot
library(rpart)
library(rpart.plot)
# Create a decision tree model
Anomaly <- as.vector(results$outlier)
rpart.df <- cbind(maindf[1:4],Anomaly)
tree <- rpart(Anomaly~., data=rpart.df)
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdBu", shadow.col="gray", nn=TRUE)
install.packages("party")
library(party)
fit <- ctree(Anomaly~., data=rpart.df)
plot(fit, main="Conditional Inference Tree for Kyphosis")
View(rpart.df)
View(rpart.df)
# Load rpart and rpart.plot
library(rpart)
library(rpart.plot)
# Create a decision tree model
Anomaly <- as.vector(results$outlier)
rpart.df <- cbind(maindf[1:4],Anomaly)
tree <- rpart(Anomaly~., data=rpart.df, method="class")
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdBuGR", shadow.col="gray", nn=TRUE,type = 3, clip.right.labs = FALSE, branch = .3, under = TRUE)
# Load rpart and rpart.plot
library(rpart)
library(rpart.plot)
# Create a decision tree model
Anomaly <- as.vector(results$outlier)
rpart.df <- cbind(maindf[1:4],Anomaly)
tree <- rpart(Anomaly~., data=rpart.df, method="class")
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdBuGn", shadow.col="gray", nn=TRUE,type = 3, clip.right.labs = FALSE, branch = .3, under = TRUE)
# Load rpart and rpart.plot
library(rpart)
library(rpart.plot)
# Create a decision tree model
Anomaly <- as.vector(results$outlier)
rpart.df <- cbind(maindf[1:4],Anomaly)
tree <- rpart(Anomaly~., data=rpart.df, method="class")
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdBuGn", shadow.col="gray", nn=TRUE,type = 3, clip.right.labs = FALSE, branch = .3, under = TRUE)
# Load rpart and rpart.plot
library(rpart)
library(rpart.plot)
# Create a decision tree model
Anomaly <- as.vector(results$outlier)
rpart.df <- cbind(maindf[1:4],Anomaly)
tree <- rpart(Anomaly~., data=rpart.df, method="class")
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE,type = 3, clip.right.labs = FALSE, branch = .3, under = TRUE)
rpart.rules(tree, cover = TRUE)
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE)
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE, type = 3, clip.right.labs = FALSE, branch = .3, under = TRUE)
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE clip.right.labs = FALSE, branch = .3, under = TRUE)
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE, clip.right.labs = FALSE, branch = .3, under = TRUE)
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE)
rpart.rules(tree, cover = TRUE)
print(rpart.rules(tree, cover = TRUE)
print(rpart.rules(tree, cover = TRUE))
print(rpart.rules(tree, cover = TRUE))
levels(rpart.df$Anomaly)
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE)
print(rpart.rules(tree,extra = 4, cover = TRUE))
TREE_RULES <- rpart.rules(tree,extra = 4, cover = TRUE))
TREE_RULES <- rpart.rules(tree,extra = 4, cover = TRUE)
View(sens.ci)
View(TREE_RULES)
View(TREE_RULES)
library(shiny)
shiny::runApp(system.file("shiny", package = "visNetwork"))
library(shiny)
library(visNetwork)
visTree(tree, main = "Classification Tree", width = "100%")
install.packages("visNetwork")
visTree(tree, main = "Classification Tree", width = "100%")
library(shiny)
library(visNetwork)
visTree(tree, main = "Classification Tree", width = "100%")
install.packages("sparkline")
visTree(tree, main = "Classification Tree", width = "100%")
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE, clip.right.labs = FALSE, branch = .3, under = TRUE)
# Load rpart and rpart.plot
library(rpart)
library(rpart.plot)
# Visualize the decision tree with rpart.plot
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE, clip.right.labs = FALSE, branch = .3, under = TRUE)
visTree(tree, main = "Classification Tree", width = "100%")
?visTree
TREE_RULES <- rpart.rules(tree,extra = 4, cover = TRUE)
rpart.plot(tree, box.palette="RdGn", shadow.col="gray", nn=TRUE)
?prp
runApp('~/Desktop/GitHub/MSstatsQCgui_v2.0')
runApp('~/Desktop/GitHub/MSstatsQCgui_v2.0')
View(results)
View(results)
View(results)
library(solitude)
library(dplyr)
# utility dir func (moved necessary dependancies in src folder in root of repo)
dir <- getwd()
if (tail(strsplit(dir,"/")[[1]],1) == "isolationforest"){
guide.set <- read.csv("guide_set.csv")
setwd("..")
source("isolationforest/simulate_test_data.R")
setwd(dir)
}
#You need to first run simulation code to create a Data.set
input_df <- Data.set
levels(input_df$peptide)
# input_df <- input_df %>% filter(peptide != "EACFAVEGPK")
input_df <- input_df %>% filter(peptide == "SLHTLFGDELCK")
input_df <- input_df[,2:7]
pass <-  input_df[input_df$RESPONSE == "PASS",]
fail <-  input_df[input_df$RESPONSE == "FAIL",]
maindf <- rbind(sample_frac(pass,0.95),sample_frac(fail,0.05)) %>% dplyr::select(-peptide)
iso <- isolationForest$new(
num_trees = 100,
sample_size = nrow(maindf)*0.05,
replace = T,
mtry = base::round(sqrt(length(colnames(maindf)))),
seed = 123
)
# fit for data
iso$fit(maindf[,1:4])
# fit for data
iso$fit(maindf[,1:4])
results <- iso$predict(maindf[,1:4])
# quantiles of anomaly scores
contamination.factor<-0.95
View(results)
View(results)
runApp('~/Desktop/GitHub/MSstatsQCgui_v2.0')
runApp('~/Desktop/GitHub/MSstatsQCgui_v2.0')
runApp('~/Desktop/GitHub/MSstatsQCgui_v2.0')
# library(shiny)
# library(shinythemes)
# library(DT)
# library(shinyBS)
# library(waiter)
# library(pushbar)
# library(shinyjs)
# library(shinyWidgets)
# library(plotly)
#
mod1_ui <-fluidPage(
navbarPage(id = "inTabset",
theme = 'cosmo.min.css', position = 'fixed-top',
title = div(id='Logo',
div(img(src="logo.png", height=50),
p("MSstatsQC - Module 1",style = "font-size:25px;
padding-left:20px;
padding-top:5%"),
style= "display:flex"),
),
windowTitle = "MSstatsQC - Module 1",
header=tags$head(
tags$style(HTML('body { padding-top: 8%; }
.navbar > .container-fluid {
padding-left:5%;
padding-right:5%;
box-shadow: 0 6px 2px -2px rgba(0,0,0,.5);
background-color:#1d1d1f;}
.navbar .navbar-nav {float: right}
.navbar-nav > li > a > .fa { padding-right:30px }
.navbar-nav > li > a > b { margin-left:10px }
.navbar-nav > li > a, .navbar-brand {
font-size: 1.5rem;
letter-spacing: 1px;
margin:0;
padding-top:auto;
padding-bottom:1%;
align-items: center;
display: flex;
height: 10vh;
.navbar-default .navbar-nav > a > .active:after {
position: absolute;
bottom: 0;
left: 0;
width: 100%;
}
.navbar {min-height:250px !important;}
.modal-body{min-height:70vh !important; align:center}
.modal-content, modal-lg {min-width: 80vw;}'))
),
tabPanel(title= "About", value = "panel1",icon = icon("bar-chart-o"),
fluidPage(style= 'font-size: 20px;',
fluidRow(column(8,offset = 2,
includeMarkdown("www/mod1.md"),
actionButton("jumpToP2","Begin")
)))),
tabPanel(title = "Data Import & Plotting",value = "panel2", icon = icon("upload"), id='upload_tab',
fluidPage(style = "width:95%",
fluidRow(
column(6,wellPanel(DT::dataTableOutput("table", height ="50vh"))),
column(6,
fluidPage(
tabsetPanel(
tabPanel(title = "PCA Plot", plotlyOutput('plot',height='60vh')),
tabPanel(title = "Tree Plot", visNetworkOutput("tree"))
)
),
)
),
wellPanel(fluidRow(
column(3,fileInput("anomalyfilein", label= p(strong("Upload Dataset")), accept = c(".csv"))),
column(2,numericInput("lb", div("Starting Col Idx:", style="padding-bottom:6%;"),1, min = 1)),
column(2,numericInput("ub", div("Ending Col Idx:", style="padding-bottom:6%;"), 2,min = 1)),
column(4,sliderInput("cf", "Contamination Factor:",
min = 0, max = 1,
value = 0.05, step = 0.01)),
column(1,actionGroupButtons(
c("go", "clear_button"),
c("Plot!", "Clear Data"),
status = "default",
size = "normal",
direction = "vertical",
fullwidth = FALSE
))
))
)
)
)
)
# library(shiny)
# library(shinythemes)
# library(DT)
# library(shinyBS)
# library(waiter)
# library(pushbar)
# library(shinyjs)
# library(shinyWidgets)
# library(plotly)
#
mod1_ui <-fluidPage(
navbarPage(id = "inTabset",
theme = 'cosmo.min.css', position = 'fixed-top',
title = div(id='Logo',
div(img(src="logo.png", height=50),
p("MSstatsQC - Module 1",style = "font-size:25px;
padding-left:20px;
padding-top:5%"),
style= "display:flex"),
),
windowTitle = "MSstatsQC - Module 1",
header=tags$head(
tags$style(HTML('body { padding-top: 8%; }
.navbar > .container-fluid {
padding-left:5%;
padding-right:5%;
box-shadow: 0 6px 2px -2px rgba(0,0,0,.5);
background-color:#1d1d1f;}
.navbar .navbar-nav {float: right}
.navbar-nav > li > a > .fa { padding-right:30px }
.navbar-nav > li > a > b { margin-left:10px }
.navbar-nav > li > a, .navbar-brand {
font-size: 1.5rem;
letter-spacing: 1px;
margin:0;
padding-top:auto;
padding-bottom:1%;
align-items: center;
display: flex;
height: 10vh;
.navbar-default .navbar-nav > a > .active:after {
position: absolute;
bottom: 0;
left: 0;
width: 100%;
}
.navbar {min-height:250px !important;}
.modal-body{min-height:70vh !important; align:center}
.modal-content, modal-lg {min-width: 80vw;}'))
),
tabPanel(title= "About", value = "panel1",icon = icon("bar-chart-o"),
fluidPage(style= 'font-size: 20px;',
fluidRow(column(8,offset = 2,
includeMarkdown("www/mod1.md"),
actionButton("jumpToP2","Begin")
)))),
tabPanel(title = "Data Import & Plotting",value = "panel2", icon = icon("upload"), id='upload_tab',
fluidPage(style = "width:95%",
fluidRow(
column(6,wellPanel(DT::dataTableOutput("table", height ="50vh"))),
column(6,
fluidPage(
tabsetPanel(
tabPanel(title = "PCA Plot", plotlyOutput('plot',height='60vh')),
tabPanel(title = "Tree Plot", visNetworkOutput("tree"))
)
),
)
),
wellPanel(fluidRow(
column(3,fileInput("anomalyfilein", label= p(strong("Upload Dataset")), accept = c(".csv"))),
column(2,numericInput("lb", div("Starting Col Idx:", style="padding-bottom:6%;"),1, min = 1)),
column(2,numericInput("ub", div("Ending Col Idx:", style="padding-bottom:6%;"), 2,min = 1)),
column(4,sliderInput("cf", "Contamination Factor:",
min = 0, max = 1,
value = 0.05, step = 0.01)),
column(1,actionGroupButtons(
c("go", "clear_button"),
c("Plot!", "Clear Data"),
status = "default",
size = "normal",
direction = "vertical",
fullwidth = FALSE
))
))
)
)
)
)
