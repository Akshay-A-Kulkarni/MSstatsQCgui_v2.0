source("simulate_test_data.R")
input_df <- Data.set
contamination.factor<-0.95
pass <-  input_df[input_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  input_df[input_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
fullDF <- rbind(pass,fail) %>% filter(peptide == "SLHTLFGDELCK") %>% dplyr::select(3:7)
maindf <- fullDF[2:5]
# scale all numeric cols
num_cols <- colnames(dplyr::select_if(maindf, is.numeric))
maindf <- maindf %>% mutate_at(num_cols, ~(scale(., center = T) %>% as.vector))
# Find outliers by setting an optional k
outlier_score <- LOOP(dataset=maindf, k=20, lambda=3)
# Sort and find index for most outlying observations
names(outlier_score) <- 1:nrow(maindf)
sort(outlier_score, decreasing = TRUE)
# Inspect the distribution of outlier scores
hist(outlier_score)
contamination.factor = 0.95
# Inspect the distribution of outlier scores
hist(outlier_score)
contamination.factor = 0.95
n = length(outlier_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(outlier_score[boot.sample], contamination.factor)
}
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(outlier_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
thresh<-median(boot_result)
outlier <- as.vector(if_else(outlier_score > thresh, 'FAIL', 'PASS'))
response <- as.vector(if_else(fullDF$RESPONSE == "FAIL", 'FAIL', 'PASS'))
table(outlier, response)
roc1 <- roc(response = fullDF$RESPONSE,
predictor = outlier_score, percent=TRUE,
# arguments for ci
ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(maindf)*0.05 + 2),
replace = T,
mtry = 4,
seed = 123
)
# fit for data
iso$fit(maindf)
results <- iso$predict(maindf)
#2. way of calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
outlier<-as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,fullDF$RESPONSE)
RESPONSE <- as.vector(fullDF$RESPONSE)
outlier<-as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
roc_iso <- roc(response = fullDF$RESPONSE,
predictor = outlier_score, percent=TRUE,
# arguments for ci
ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
roc_iso <- roc(response = fullDF$RESPONSE,
predictor = results$anomaly_score, percent=TRUE,
# arguments for ci
ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
table(outlier,RESPONSE)
?roc
runApp('~/Desktop/GitHub/MSstatsQCgui_v2.0')
library(Rlof)
library(Rlof)
input_rawdf <- read.csv("simData_delta7.csv")
input_df <- input_df %>% filter(peptide == "SLHTLFGDELCK") %>% dplyr::select(3:7)
View(input_rawdf)
dir <- getwd()
if (tail(strsplit(dir,"/")[[1]],1) == "isolationforest"){
guide.set <- read.csv("guide_set.csv")
setwd("..")
source("isolationforest/simulate_test_data.R")
setwd(dir)
}
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
length(inputDF)
library(solitude)
library(dplyr)
library(pROC)
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
#You need to first run simulation code to create a Data.set
input_df <- Data.set
peps <- levels(input_df$peptide)[6]
input_df <- input_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor<-0.95
pass <-  input_df[input_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  input_df[input_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
DF <- rbind(pass,fail)
length(DF)
View(DF)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
DF
DF[cols]
library(solitude)
library(dplyr)
library(pROC)
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
source("simulate_test_data.R")
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[6]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor<-0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.05 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(inputDF$RESPONSE)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
roc_iso <- roc(response = inputDF$RESPONSE,
predictor = results$anomaly_score, percent=TRUE,
# arguments for ci
ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
roc_iso <- roc(response = input_df$RESPONSE,
predictor = results$anomaly_score, percent=TRUE,
# arguments for ci
ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
peps <- levels(raw_df$peptide)[7]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
library(solitude)
library(dplyr)
library(pROC)
library(solitude)
library(dplyr)
library(pROC)
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
source("simulate_test_data.R")
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[7]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor<-0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.05 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
roc_iso <- roc(response = input_df$RESPONSE,
predictor = results$anomaly_score, percent=TRUE,
# arguments for ci
ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
library(solitude)
library(dplyr)
library(dplyr)
library(pROC)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
source("simulate_test_data.R")
#Sanity check beta val
print(betaVal)
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[6]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor <- 0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.1 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
contamination.factor <- 0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.1 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
library(DDoutlier)
library(DDoutlier)
guide.set <- read.csv("guide_set.csv")
guide.set <- read.csv("guide_set.csv")
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
source("simulate_test_data.R")
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[6]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor <- 0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
maindf <- input_df[cols]
# scale all numeric cols
num_cols <- colnames(dplyr::select_if(maindf, is.numeric))
maindf <- maindf %>% mutate_at(num_cols, ~(scale(., center = T) %>% as.vector))
# Find outliers by setting an optional k
outlier_score <- LOOP(dataset=maindf, k=15, lambda=3)
# Sort and find index for most outlying observations
names(outlier_score) <- 1:nrow(maindf)
sort(outlier_score, decreasing = TRUE)
contamination.factor = 0.95
n = length(outlier_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(outlier_score[boot.sample], contamination.factor)
}
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(outlier_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
outlier <- as.vector(if_else(outlier_score > thresh, 'FAIL', 'PASS'))
response <- as.vector(if_else(fullDF$RESPONSE == "FAIL", 'FAIL', 'PASS'))
response <- as.vector(if_else(input_df$RESPONSE == "FAIL", 'FAIL', 'PASS'))
table(outlier, response)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.1 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
library(solitude)
library(dplyr)
library(pROC)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
#Sanity check beta val
print(betaVal)
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[6]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor <- 0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.1 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2, xlim = c(80, 20))
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2, xlim = c(80, 20))
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2, xlim = c(80, 20))
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
# legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2, xlim = c(80, 20))
# legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6",xlim = c(80, 20))
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600",xlim = c(80, 20))
testobj <- roc.test(rocobj1, rocobj2)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6",xlim = c(100, 0))
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600",xlim = c(100,0))
testobj <- roc.test(rocobj1, rocobj2)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6",xlim = c(100, 0),add=FALSE)
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600",xlim = c(100,0),add=FALSE)
testobj <- roc.test(rocobj1, rocobj2)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6",xlim = c(100, 0),add=FALSE)
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600",xlim = c(100,0),add=FALSE)
testobj <- roc.test(rocobj1, rocobj2, xlim = c(100,0),add=FALSE))
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6",xlim = c(100, 0),add=FALSE)
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600",xlim = c(100,0),add=FALSE)
testobj <- roc.test(rocobj1, rocobj2, xlim = c(100,0),add=FALSE)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
shiny::runApp('~/Desktop/GitHub/MSstatsQCgui_v2.0')
