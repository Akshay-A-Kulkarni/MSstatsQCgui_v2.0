# library(tidyr)
# library(rpart)
# library(rpart.plot)
# library(visNetwork)
#
#
plot_pca <- function(data, label_idx = NULL){
if (is.null(label_idx)){
label_idx = length(data)
}
# Assumes all numeric cols with anomaly score col last
num_cols <- colnames(dplyr::select_if(input_df, is.numeric))
pca <- prcomp(data[c(num_cols)], scale. = T , center = T)
pcainfo <-  summary(pca)
x <- as.vector(pca[["x"]][,1])
y <- as.vector(pca[["x"]][,2])
z <- as.vector(pca[["x"]][,3])
label_col <- base::as.vector(data[,label_idx])
pca_df <-  as.data.frame(cbind(x,y,z,label_col))
pca_df <- pca_df %>% mutate(label_col = if_else(label_col == "FAIL", 'Anomaly', 'Normal') )
fig <- plot_ly(pca_df, x = ~x, y = ~y, z = ~z, color = ~label_col, colors = c('#BF382A', '#0C4B8E'), symbols = ~label_col)
fig <- fig %>% add_markers()
fig <- fig %>% layout(scene = list(xaxis = list(title = paste('PC1 ', pcainfo$importance[2]*100,"%")),
yaxis = list(title = paste('PC2 ', pcainfo$importance[5]*100,"%")),
zaxis = list(title = paste('PC3 ', pcainfo$importance[8]*100,"%"))))
fig
}
anom_df <- read.csv("Datasets/SimData.csv")
plot(plot_pca(anom_df))
# library(solitude)
# library(dplyr)
# library(pROC)
# library(plotly)
# library(tidyr)
# library(rpart)
# library(rpart.plot)
# library(visNetwork)
#
#
plot_pca <- function(data, label_idx = NULL){
if (is.null(label_idx)){
label_idx = length(data)
}
# Assumes all numeric cols with anomaly score col last
num_cols <- colnames(dplyr::select_if(input_df, is.numeric))
pca <- prcomp(data[c(num_cols)], scale. = T , center = T)
pcainfo <-  summary(pca)
x <- as.vector(pca[["x"]][,1])
y <- as.vector(pca[["x"]][,2])
z <- as.vector(pca[["x"]][,3])
label_col <- base::as.vector(data[,label_idx])
pca_df <-  as.data.frame(cbind(x,y,z,label_col))
pca_df <- pca_df %>% mutate(label_col = if_else(label_col == "FAIL", 'Anomaly', 'Normal') )
fig <- plot_ly(pca_df, x = ~x, y = ~y, z = ~z, color = ~label_col, colors = c('#BF382A', '#0C4B8E'), symbols = ~label_col)
fig <- fig %>% add_markers()
fig <- fig %>% layout(scene = list(xaxis = list(title = paste('PC1 ', pcainfo$importance[2]*100,"%")),
yaxis = list(title = paste('PC2 ', pcainfo$importance[5]*100,"%")),
zaxis = list(title = paste('PC3 ', pcainfo$importance[8]*100,"%"))))
fig
}
anom_df <- read.csv("Datasets/SimData.csv")
plot(plot_pca(anom_df))
shiny::runApp()
runApp()
if("prettydoc" %in% rownames(installed.packages()) == FALSE) {install.packages("prettydoc")}
runApp()
runApp()
runApp()
if("prettydoc" %in% rownames(installed.packages()) == FALSE) {install.packages("prettydoc")}
library(rpart)
library(visNetwork)
knitr::opts_chunk$set(fig.align="center")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?actionGroupButtons
runApp()
runApp()
runApp()
runApp()
library(solitude)
library(dplyr)
library(dplyr)
library(pROC)
library(solitude)
library(dplyr)
library(pROC)
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[7]
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[6]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor <- 0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.05 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
input_df[cols]
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
getwd()
library(solitude)
library(dplyr)
library(pROC)
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
source("simulate_test_data.R")
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[6]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor <- 0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.05 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
library(solitude)
library(dplyr)
library(pROC)
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
library(solitude)
library(dplyr)
library(pROC)
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
source("simulate_test_data.R")
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[6]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor <- 0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.1 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
library(solitude)
library(solitude)
library(dplyr)
library(pROC)
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
print(beta)
library(solitude)
library(dplyr)
library(pROC)
# utility dir func (moved necessary dependancies in src folder in root of repo)
guide.set <- read.csv("guide_set.csv")
source("simulate_test_data.R")
print(beta)
print(betaVal)
#You need to first run simulation code to create a Data.set
raw_df <- Data.set
peps <- levels(raw_df$peptide)[6]
raw_df <- raw_df[,2:7] %>% filter(peptide %in% peps)
contamination.factor <- 0.95
pass <-  raw_df[raw_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  raw_df[raw_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- rbind(pass,fail)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.8 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
iso <- isolationForest$new(
num_trees = 100,
sample_size = base::round(nrow(input_df)*0.1 + 2),
replace = T,
mtry = base::round(sqrt(length(input_df))),
seed = 123
)
# fit for data
iso$fit(input_df[cols])
# obtain Scores
results <- iso$predict(input_df[cols])
# Calculating q based on bootstrap
n = length(results$anomaly_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(results$anomaly_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
RESPONSE <- as.vector(input_df$RESPONSE)
outlier <- as.vector(ifelse(results$anomaly_score > thresh, "FAIL", "PASS"))
table(outlier,RESPONSE)
roc_iso <- roc(response = input_df$RESPONSE,
predictor = results$anomaly_score, percent=TRUE,
# arguments for ci
ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
install.packages("PRROC")
install.packages("PRROC", dependencies = T)
require(PRROC)
roc_iso <- roc(response = input_df$RESPONSE,
predictor = results$anomaly_score, percent=TRUE,
# arguments for ci
ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
require(PRROC)
scores = as.vector(results$anomaly_score)
positive_class <- scores[input_df$RESPONSE == 'FAIL']
negative_class <- scores[input_df$RESPONSE == 'PASS']
# ROC Curve
roc <- roc.curve(scores.class0 = positive_class, scores.class1 = negative_class, curve = T)
plot(roc)
# PR Curve
pr <- pr.curve(scores.class0 = positive_class, scores.class1 = negative_class, curve = T)
plot(pr)
library(DDoutlier)
input_df <- Data.set
contamination.factor<-0.95
pass <-  input_df[input_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  input_df[input_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
fullDF <- rbind(pass,fail) %>% filter(peptide == "SLHTLFGDELCK") %>% dplyr::select(3:7)
maindf <- fullDF[2:5]
maindf <- fullDF[cols]
# scale all numeric cols
num_cols <- colnames(dplyr::select_if(maindf, is.numeric))
maindf <- maindf %>% mutate_at(num_cols, ~(scale(., center = T) %>% as.vector))
# Find outliers by setting an optional k
outlier_score <- LOOP(dataset=maindf, k=20, lambda=3)
# Sort and find index for most outlying observations
names(outlier_score) <- 1:nrow(maindf)
sort(outlier_score, decreasing = TRUE)
# Inspect the distribution of outlier scores
hist(outlier_score)
contamination.factor = 0.95
n = length(outlier_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(outlier_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
outlier <- as.vector(if_else(outlier_score > thresh, 'FAIL', 'PASS'))
response <- as.vector(if_else(fullDF$RESPONSE == "FAIL", 'FAIL', 'PASS'))
table(outlier, response)
library(pROC)
rocobj1 <- plot.roc(input_df$RESPONSE, results$anomaly_score,
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(input_df$RESPONSE, outlier_score,
percent=TRUE,
col="#008600")
library(pROC)
rocobj1 <- plot.roc(input_df$RESPONSE, results$anomaly_score,
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(input_df$RESPONSE, outlier_score,
percent=TRUE,
col="#008600")
View(input_df)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
text(50, 50, labels=paste("p-value =", format.pval(testobj$p.value)), adj=c(0, .5))
legend("bottomright", legend=c("S100B", "NDKA"), col=c("#1c61b6", "#008600"), lwd=2)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="Statistical comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier,
percent=TRUE,
col="#008600")
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="Statistical comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
text(50, 50, labels=paste("p-value =", format.pval(testobj$p.value)), adj=c(0, .5))
legend("bottomright", legend=c("S100B", "NDKA"), col=c("#1c61b6", "#008600"), lwd=2)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="Statistical comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- plot.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
text(50, 50, labels=paste("p-value =", format.pval(testobj$p.value)), adj=c(0, .5))
legend("bottomright", legend=c("S100B", "NDKA"), col=c("#1c61b6", "#008600"), lwd=2)
rocobj2 <- plot.roc(response, outlier_score,
percent=TRUE,
col="#008600")
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="Statistical comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
text(50, 50, labels=paste("p-value =", format.pval(testobj$p.value)), adj=c(0, .5))
legend("bottomright", legend=c("S100B", "NDKA"), col=c("#1c61b6", "#008600"), lwd=2)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="Statistical comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
text(50, 50, labels=paste("p-value =", format.pval(testobj$p.value)), adj=c(0, .5))
legend("bottomright", legend=c("S100B", "NDKA"), col=c("#1c61b6", "#008600"), lwd=2)
## Plotting a single decision tree fitted on data given by isoforest.
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
text(50, 50, labels=paste("p-value =", format.pval(testobj$p.value)), adj=c(0, .5))
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
cols <- c("RT","TotalArea","MassAccu", "FWHM")
input_df <- Data.set
contamination.factor<-0.95
pass <-  input_df[input_df$RESPONSE == "PASS",] %>% group_by(peptide) %>% sample_frac(contamination.factor)
fail <-  input_df[input_df$RESPONSE == "FAIL",] %>% group_by(peptide) %>% sample_frac(1-contamination.factor)
fullDF <- rbind(pass,fail) %>% filter(peptide == "SLHTLFGDELCK") %>% dplyr::select(3:7)
maindf <- fullDF[cols]
# scale all numeric cols
num_cols <- colnames(dplyr::select_if(maindf, is.numeric))
maindf <- maindf %>% mutate_at(num_cols, ~(scale(., center = T) %>% as.vector))
# Find outliers by setting an optional k
outlier_score <- LOOP(dataset=maindf, k=10, lambda=3)
# Sort and find index for most outlying observations
names(outlier_score) <- 1:nrow(maindf)
sort(outlier_score, decreasing = TRUE)
# Inspect the distribution of outlier scores
hist(outlier_score)
contamination.factor = 0.95
n = length(outlier_score)/2
B = 10000
boot_result = rep(NA, B)
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(outlier_score[boot.sample], contamination.factor)
}
for (i in 1:B) {
boot.sample = sample(n, replace = TRUE)
boot_result[i] = quantile(outlier_score[boot.sample], contamination.factor)
}
thresh<-median(boot_result)
outlier <- as.vector(if_else(outlier_score > thresh, 'FAIL', 'PASS'))
response <- as.vector(if_else(fullDF$RESPONSE == "FAIL", 'FAIL', 'PASS'))
table(outlier, response)
library(pROC)
rocobj1 <- plot.roc(RESPONSE, results$anomaly_score,
main="ROC comparison",
percent=TRUE,
col="#1c61b6")
rocobj2 <- lines.roc(response, outlier_score,
percent=TRUE,
col="#008600")
testobj <- roc.test(rocobj1, rocobj2)
legend("bottomright", legend=c("Isolation Forest", "LoOP"), col=c("#1c61b6", "#008600"), lwd=2)
