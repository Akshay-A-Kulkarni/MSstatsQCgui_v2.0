my_height <- reactive({
l <- length(input$user_selected_metrics)
k <- length(input$summary_controlChart_select)
if(l < 5) {
my_height <- ceiling(k)*700
}else if(l < 9) {
my_height <- ceiling(k)*1300
}else if(l <15) {
my_height <- ceiling(k)*1700
}else if(l < 20) {
my_height <- ceiling(k)*2000
}else if(l < 25) {
my_height <- ceiling(k)*2300
}else {
my_height <- ceiling(k)*2600
}
})
my_width <- reactive({
l = length(input$user_selected_metrics)
if(l == 1) {
my_width = 300
}else if(l == 2) {
my_width = 800
}else if(l == 3) {
my_width = 1200
}
my_width <- 1400
})
heatmap_height <- reactive({
l <- length(input$user_selected_metrics)
k <- length(input$heatmap_controlChart_select)
if(l == 1) {
heatmap_height <- ceiling(k)*300
}else {
heatmap_height <- ceiling(k)*ceiling(l)*200
}
})
heatmap_width <- reactive({
heatmap_width <- 1000
})
########################################################## box plot in Metric Summary tab ##########################################
output$box_plot <- renderPlotly({
prodata <- data$df
validate(
need(!is.null(prodata), "Please upload your data"),
need(is.data.frame(prodata), prodata),
need(!is.null(input$user_selected_metrics),"Please first select metrics and create a decision rule")
)
metrics_box.plot(prodata, data.metrics = input$user_selected_metrics) %>% layout(width = JS('0.9*window.innerWidth'))
})
output$box_plotly <- renderUI({
prodata <- data$df
validate(
need(!is.null(prodata), "Please upload your data"),
need(is.data.frame(prodata), prodata),
need(!is.null(input$user_selected_metrics),"Please first select metrics and create a decision rule")
)
plotly_box_plots <- metrics_box.plot(prodata, data.metrics = input$user_selected_metrics, ret_obj_list = T)
get_plot_output_list <- function(input_n) {
# Insert plot output objects the list
plot_output_list <- lapply(1:input_n, function(i) {
plotname <- paste("boxplot", i, sep="")
plot_output_object <- plotlyOutput(plotname)
plot_output_object <- wellPanel(h3(strong(input$user_selected_metrics[[i]])),br(),
renderPlotly({ plotly_box_plots[[i]]}))
})
do.call(tagList, plot_output_list) # needed to display properly.
return(plot_output_list)
}
get_plot_output_list(length(plotly_box_plots))
})
###############   summary plots and radar plots ############################################################################
output$plot_summary <- renderPlot({
prodata <- data$df
validate(
need(!is.null(prodata), "Please upload your data"),
need(is.data.frame(prodata), prodata),
need(!is.null(input$user_selected_metrics),"Please first select metrics and create a decision rule")
)
is_guidset_selected <- FALSE
if(input$selectGuideSetOrMeanSD == "Mean and standard deviation estimated from guide set") {
is_guidset_selected <- TRUE
}
listMean <- list()
listSD <- list()
for(metric in input$user_selected_metrics){
listMean[[metric]] <- input[[paste0("selectMean@",metric)]]
listSD[[metric]] <- input[[paste0("selectSD@",metric)]]
}
plots <- list()
i <- 1
for(method in input$summary_controlChart_select) {
p1 <- NULL
p2 <- NULL
if(method == "XmR") {
p1 <- XmR.Summary.plot(prodata, data.metrics = input$user_selected_metrics, input$L, input$U, listMean = listMean,listSD = listSD, guidset_selected = is_guidset_selected)
p2 <- XmR.Radar.Plot(prodata, data.metrics = input$user_selected_metrics,input$L,input$U,listMean = listMean,listSD = listSD, guidset_selected = is_guidset_selected)
} else if(method == "CUSUM") {
p1 <- CUSUM.Summary.plot(prodata, data.metrics = input$user_selected_metrics, input$L, input$U,listMean = listMean,listSD = listSD, guidset_selected = is_guidset_selected)
p2 <- CUSUM.Radar.Plot(prodata, data.metrics = input$user_selected_metrics, input$L,input$U,listMean = listMean,listSD = listSD, guidset_selected = is_guidset_selected)
}
plots[[i]]   <- p1
plots[[i+1]] <- p2
i <- i+2
}
if(length(plots) > 0)
do.call("grid.arrange", c(plots, ncol = 1))
}, height = my_height, width = my_width)
############################# heat_map in Summary tab #############################################
output$heat_map <- renderPlot({
prodata <- data$df
validate(
need(!is.null(prodata), "Please upload your data"),
need(is.data.frame(prodata), prodata),
need(!is.null(input$user_selected_metrics),"Please first select metrics and create a decision rule"),
need(!is.null(prodata$AcquiredTime),"To view heatmaps, the dataset should include Acquired Time column.")
)
peptideThresholdRed <- (as.numeric(input$threshold_peptide_red))/100
peptideThresholdYellow <- (as.numeric(input$threshold_peptide_yellow))/100
if(is.null(prodata$AcquiredTime)) return(NULL)
is_guidset_selected <- FALSE
if(input$selectGuideSetOrMeanSD == "Mean and standard deviation estimated from guide set") {
is_guidset_selected <- TRUE
}
listMean <- list()
listSD <- list()
for(metric in input$user_selected_metrics){
listMean[[metric]] <- input[[paste0("selectMean@",metric)]]
listSD[[metric]] <- input[[paste0("selectSD@",metric)]]
}
plots <- list()
i <- 1
for(method in input$heatmap_controlChart_select) {
p1 <- metrics_heat.map(prodata,
data.metrics = input$user_selected_metrics, method = method,
peptideThresholdRed, peptideThresholdYellow,input$L, input$U, type = 1,
title = "Decision-map : mean",
listMean = listMean, listSD = listSD, guidset_selected = is_guidset_selected)
p2 <- metrics_heat.map(prodata,
data.metrics = input$user_selected_metrics, method = method,
peptideThresholdRed, peptideThresholdYellow,input$L, input$U, type = 2,
title = "Decision-map : variability",
listMean = listMean, listSD = listSD, guidset_selected = is_guidset_selected)
plots[[i]]   <- p1
plots[[i+1]] <- p2
i <- i+2
}
if(length(plots) > 0)
do.call("grid.arrange", c(plots, ncol = 1))
}, height = heatmap_height, width = heatmap_width)
# session$onSessionEnded(function() {
#   stopApp()
# })
}
# Run the app ----
shinyApp(ui = mod2_ui, server = mod2_server)
runApp()
runApp()
install.packages("tippy")
install.packages("tippy")
runApp()
runApp()
runApp()
install.packages("tippy")
install.packages("tippy")
shiny::runApp()
runApp()
install.packages("tippy")
shiny::runApp()
runApp()
library(tippy)
runApp()
runApp()
library(shiny)
library(shiny.router)
library(shinythemes)
library(DT)
library(shinyBS)
library(shinyjs)
library(shinyWidgets)
library(waiter)
library(pushbar)
library(bsplus)
library(htmltools)
#####################################
library(plotly)
library(RecordLinkage)
library(MSstatsQC)
library(MSstatsQCgui)
library(dplyr)
library(ggExtra)
library(gridExtra)
library(grid)
library(fresh)
library(tippy)
if (!"package:MSstatsQCgui" %in% search())
import_fs("MSstatsQCgui", incl = c("shiny","shinyBS","dplyr","plotly","RecordLinkage","ggExtra","gridExtra","grid"))
# ARCHIVED RECORD LINKAGE PACKAGE.
# RecordLinkageURL <- "https://cran.r-project.org/src/contrib/Archive/RecordLinkage/RecordLinkage_0.4-11.tar.gz"
# install.packages(RecordLinkageURL, repos=NULL, type="source")
# Sourcing all modules pages to the main routing app.
source("src/module1-ui.R")
source("src/module1-server.R")
source("src/module2-ui.R")
source("src/module2-server.R")
source("src/module3-ui.R")
source("src/module3-server.R")
cardCSS <- "box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
border-radius: 0.5rem;
box-shadow: 7px 7px 30px -5px rgba(0,0,0,0.1);
position: relative;
height: 50%;"
# Main Home Page cards
mod1p <- div(h4(strong("One Time QC")),br(),
fluidRow(
column(5,img(src='mod1.png',width="100%")),
column(7,p("Allows the user to upload data of one time runs to assess optimality w.r.t the guide set "),br(),
fluidRow(column(3, offset = 0,actionButton("switch_mod1", "Launch One-Time Tool"))),br(),
fluidRow(column(2, offset = 0,actionButton("help_mod1", "Help"))))
),
)
mod2p <- div(h4(strong("Longitudinal QC")),br(),
fluidRow(
column(5,img(src='mod2.png',width="100%")),
column(7,p("Allows the user to upload data of one or more peptide to assess optimality w.r.t the guide set for multiple runs"),br(),
fluidRow(column(3, offset = 0,actionButton("switch_mod2", "Launch Longitudinal Tool"))),br(),
fluidRow(column(2, offset = 0,actionButton("help_mod2", "Help")))
)
),
)
mod3p <- div(h4(strong("Complex QC")),br(),
fluidRow(column(5,img(src='mod3.png',width="100%")),
column(7,p("Allows the user to upload data of complex runs to assess optimality (Requires Test DataSet)"),br(),
fluidRow(column(3, offset = 0,actionButton("switch_mod3", "Launch Complex Tool"))), br(),
fluidRow(column(2, offset = 0, actionButton("help_mod3", "Help")))
),
)
)
# Part of both pages.
home_page <- fluidPage( style="padding:0%; margin:0%",
tags$head(
tags$style(HTML("@import url('https://fonts.googleapis.com/css?family=Open+Sans:300,400,700');
"))),
fluidRow(style="
font-family:Open Sans;
position: fixed;
width: 100%;
height: 9%;
box-shadow: 0 6px 2px -2px rgba(0,0,0,.1);
background-color:#FFF;
z-index:1000;",
fluidPage(style="width:80%;font-family:Open Sans;",
column(6,div(style="padding-top:1.5%; display:flex",img(src="logo.png", width="50vh"),div(style="padding-left:2%",h3(("MSstats"),style='color:DarkBlue; font-weight:500;')))),
column(6,align='right',
div(style="padding-top:3.5%; display:inline-block",
actionBttn(
inputId = "temporary1",
label = a("Help", href="https://google.com", target="_blank") ,
style = "bordered",
color = "success"),
actionBttn(
inputId = "temporary2",
label = a("MSstats", href="http://msstats.org/", target="_blank") ,
style = "bordered",
color = "success")
))
)),
fluidPage(style = "width:80%; padding-top:8%;font-family:Open Sans;",
fluidRow(column(7,div(style="padding-top:15%;", h1(strong('MSstatsQC'), align="right", style='font-size:5rem;'),h4('Longitudinal system suitability monitoring and quality control for proteomic experiments',align="right"))),
column(5, align='center',img(src='heat2.png', width="400vh"))
),
fluidRow(br(),br(),br(),br(),
column(12,h3("About"),
wellPanel(p(style="font-size:1.2em","Statistical process control (SPC) is a general and well-established method of quality control (QC) which can be used to monitor
and improve the quality of a process such as LC MS/MS. `MSstatsQC` and `MSstatsQCgui` are two open-source R packages for statistical
analysis and monitoring of QC and system suitability testing (SST) samples produced by spectrometry-based proteomic experiments.
Our framework termed `MSstatsQC` is available through http://www.msstats.org/msstatsqc. It uses SPC tools to track metrics including
total peak area, retention time, full width at half maximum (FWHM) and peak asymmetry for proteomic experiments. We introduce
simultaneous and time weighted control charts and change point analysis to monitor mean and variability of metrics. Proposed
longitudinal monitoring approach significantly improves the ability of real time monitoring, early detection and prevention
of chromatographic and instrumental problems of mass spectrometric assays, thereby, reducing cost of control and failure.")))),
br(),br(),
fluidRow(
column(4,wellPanel(style=cardCSS, mod1p)),
column(4,wellPanel(style=cardCSS, mod2p)),
column(4,wellPanel(style=cardCSS, mod3p)),
)
)
)
# Callbacks on the server side for the sample pages
home_server <- function(input, output, session) {
observeEvent(input$switch_mod2, {
if (!is_page("module2")) {
change_page("module2")}
})
observeEvent(input$help_mod2, {
showModal(modalDialog(
title = "Uploaded Data",
size = "l",
includeMarkdown("www/mod2.md"),
easyClose = TRUE
))
})
}
# Create routing. We provide routing path, a UI as well as a server-side callback for each page.
router <- make_router(
route("home", home_page, home_server),
route("module2", mod2_ui, mod2_server)
)
# Create output for our router in main UI of Shiny app.
ui <- fluidPage(
waiter::use_waiter(),
pushbar::pushbar_deps(),
shinyjs::useShinyjs(),
router_ui()
)
# Plug router into Shiny server.
server <- function(input, output, session) {
router(input, output, session)
# loading_screen <- tagList(
#   h3("Initializing MSstatsQC", style = "color:white;"),
#   br(),
#   waiter::spin_flower(),
#   div(style='padding:15vh')
# )
# loadScreen <- Waiter$new(html = loading_screen, color='#242424')
#
#
# loadScreen$show()
#
# Sys.sleep(2)
#
# loadScreen$update(html = tagList(img(src="logo.png", height=150),div(style='padding:15vh')))
#
# Sys.sleep(1)
#
# loadScreen$hide()
}
# Run server in a standard way.
shinyApp(ui=ui, server=server)
if (!"package:MSstatsQCgui" %in% search())
library(shiny)
library(shiny.router)
library(shinythemes)
library(DT)
library(shinyBS)
library(shinyjs)
library(shinyWidgets)
library(waiter)
library(pushbar)
library(bsplus)
library(htmltools)
#####################################
library(plotly)
library(RecordLinkage)
library(MSstatsQC)
library(MSstatsQCgui)
library(dplyr)
library(ggExtra)
library(gridExtra)
library(grid)
library(fresh)
library(tippy)
if (!"package:MSstatsQCgui" %in% search())
import_fs("MSstatsQCgui", incl = c("shiny","shinyBS","dplyr","plotly","RecordLinkage","ggExtra","gridExtra","grid"))
# ARCHIVED RECORD LINKAGE PACKAGE.
# RecordLinkageURL <- "https://cran.r-project.org/src/contrib/Archive/RecordLinkage/RecordLinkage_0.4-11.tar.gz"
# install.packages(RecordLinkageURL, repos=NULL, type="source")
# Sourcing all modules pages to the main routing app.
source("src/module1-ui.R")
source("src/module1-server.R")
source("src/module2-ui.R")
source("src/module2-server.R")
source("src/module3-ui.R")
source("src/module3-server.R")
cardCSS <- "box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
border-radius: 0.5rem;
box-shadow: 7px 7px 30px -5px rgba(0,0,0,0.1);
position: relative;
height: 50%;"
# Main Home Page cards
mod1p <- div(h4(strong("One Time QC")),br(),
fluidRow(
column(5,img(src='mod1.png',width="100%")),
column(7,p("Allows the user to upload data of one time runs to assess optimality w.r.t the guide set "),br(),
fluidRow(column(3, offset = 0,actionButton("switch_mod1", "Launch One-Time Tool"))),br(),
fluidRow(column(2, offset = 0,actionButton("help_mod1", "Help"))))
),
)
mod2p <- div(h4(strong("Longitudinal QC")),br(),
fluidRow(
column(5,img(src='mod2.png',width="100%")),
column(7,p("Allows the user to upload data of one or more peptide to assess optimality w.r.t the guide set for multiple runs"),br(),
fluidRow(column(3, offset = 0,actionButton("switch_mod2", "Launch Longitudinal Tool"))),br(),
fluidRow(column(2, offset = 0,actionButton("help_mod2", "Help")))
)
),
)
mod3p <- div(h4(strong("Complex QC")),br(),
fluidRow(column(5,img(src='mod3.png',width="100%")),
column(7,p("Allows the user to upload data of complex runs to assess optimality (Requires Test DataSet)"),br(),
fluidRow(column(3, offset = 0,actionButton("switch_mod3", "Launch Complex Tool"))), br(),
fluidRow(column(2, offset = 0, actionButton("help_mod3", "Help")))
),
)
)
# Part of both pages.
home_page <- fluidPage( style="padding:0%; margin:0%",
tags$head(
tags$style(HTML("@import url('https://fonts.googleapis.com/css?family=Open+Sans:300,400,700');
"))),
fluidRow(style="
font-family:Open Sans;
position: fixed;
width: 100%;
height: 9%;
box-shadow: 0 6px 2px -2px rgba(0,0,0,.1);
background-color:#FFF;
z-index:1000;",
fluidPage(style="width:80%;font-family:Open Sans;",
column(6,div(style="padding-top:1.5%; display:flex",img(src="logo.png", width="50vh"),div(style="padding-left:2%",h3(("MSstats"),style='color:DarkBlue; font-weight:500;')))),
column(6,align='right',
div(style="padding-top:3.5%; display:inline-block",
actionBttn(
inputId = "temporary1",
label = a("Help", href="https://google.com", target="_blank") ,
style = "bordered",
color = "success"),
actionBttn(
inputId = "temporary2",
label = a("MSstats", href="http://msstats.org/", target="_blank") ,
style = "bordered",
color = "success")
))
)),
fluidPage(style = "width:80%; padding-top:8%;font-family:Open Sans;",
fluidRow(column(7,div(style="padding-top:15%;", h1(strong('MSstatsQC'), align="right", style='font-size:5rem;'),h4('Longitudinal system suitability monitoring and quality control for proteomic experiments',align="right"))),
column(5, align='center',img(src='heat2.png', width="400vh"))
),
fluidRow(br(),br(),br(),br(),
column(12,h3("About"),
wellPanel(p(style="font-size:1.2em","Statistical process control (SPC) is a general and well-established method of quality control (QC) which can be used to monitor
and improve the quality of a process such as LC MS/MS. `MSstatsQC` and `MSstatsQCgui` are two open-source R packages for statistical
analysis and monitoring of QC and system suitability testing (SST) samples produced by spectrometry-based proteomic experiments.
Our framework termed `MSstatsQC` is available through http://www.msstats.org/msstatsqc. It uses SPC tools to track metrics including
total peak area, retention time, full width at half maximum (FWHM) and peak asymmetry for proteomic experiments. We introduce
simultaneous and time weighted control charts and change point analysis to monitor mean and variability of metrics. Proposed
longitudinal monitoring approach significantly improves the ability of real time monitoring, early detection and prevention
of chromatographic and instrumental problems of mass spectrometric assays, thereby, reducing cost of control and failure.")))),
br(),br(),
fluidRow(
column(4,wellPanel(style=cardCSS, mod1p)),
column(4,wellPanel(style=cardCSS, mod2p)),
column(4,wellPanel(style=cardCSS, mod3p)),
)
)
)
# Callbacks on the server side for the sample pages
home_server <- function(input, output, session) {
observeEvent(input$switch_mod2, {
if (!is_page("module2")) {
change_page("module2")}
})
observeEvent(input$help_mod2, {
showModal(modalDialog(
title = "Uploaded Data",
size = "l",
includeMarkdown("www/mod2.md"),
easyClose = TRUE
))
})
}
# Create routing. We provide routing path, a UI as well as a server-side callback for each page.
router <- make_router(
route("home", home_page, home_server),
route("module2", mod2_ui, mod2_server)
)
# Create output for our router in main UI of Shiny app.
ui <- fluidPage(
waiter::use_waiter(),
pushbar::pushbar_deps(),
shinyjs::useShinyjs(),
router_ui()
)
# Plug router into Shiny server.
server <- function(input, output, session) {
router(input, output, session)
# loading_screen <- tagList(
#   h3("Initializing MSstatsQC", style = "color:white;"),
#   br(),
#   waiter::spin_flower(),
#   div(style='padding:15vh')
# )
# loadScreen <- Waiter$new(html = loading_screen, color='#242424')
#
#
# loadScreen$show()
#
# Sys.sleep(2)
#
# loadScreen$update(html = tagList(img(src="logo.png", height=150),div(style='padding:15vh')))
#
# Sys.sleep(1)
#
# loadScreen$hide()
}
# Run server in a standard way.
shinyApp(ui=ui, server=server)
runApp()
runApp()
install.packages("tippy")
shiny::runApp()
